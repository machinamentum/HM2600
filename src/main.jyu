#import "LibC";
#import "GLFW";
#import "OpenGL";
#import "Array";

#load "6502.jyu";

let A12 = (1 << 12);
let A9  = (1 << 9);
let A7  = (1 << 7);

func cartridge_read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
    // Cart only accessible if A12 line is 1
    if !(_addr & A12) return (false, -1);

    var addr = _addr;
    var rom = <<cast(*string) entry.cbdata;

    addr &= M6507.ADDRESS_BITS;
    addr -= 0x1000; // map address from 0x1000-0x1FFF to 0x0000-0x0FFF

    if rom.length < 4096 {
        addr %= 2048; // mirror 2k ROM twice across the 4k address range.
    }

    return (true, rom[addr]);
}

func cartridge_write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
    // Cart only accessible if A12 line is 1
    if !(_addr & A12) return false;

    var addr = _addr;
    var rom = <<cast(*string) entry.cbdata;
    addr &= M6507.ADDRESS_BITS;
    addr -= 0x1000; // map address from 0x1000-0x1FFF to 0x0000-0x0FFF

    rom[addr] = value;

    return true;
}

struct PIA {
    var ram: [128] uint8;

    func read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
        if !(((_addr & A12) == 0) && ((_addr & A7) != 0)) return (false, -1);

        var addr = _addr;
        addr &= M6507.ADDRESS_BITS;

        var this = cast(*PIA) entry.cbdata;

        if A9 & addr {
            // PIA registers @TODO

            // @Incomplete
            return (true, -1);
        } else {
            addr = addr & 0x7F;
            return (true, this.ram[addr]);
        }
    }

    func write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
        printf("ADDR: %04X\n", _addr);
        if !(((_addr & A12) == 0) && ((_addr & A7) != 0)) return false;
        printf("asdfsdaf: %04X\n", _addr);

        var addr = _addr;
        addr &= M6507.ADDRESS_BITS;

        var this = cast(*PIA) entry.cbdata;

        if A9 & addr {
            // PIA registers @TODO

            // @Incomplete
            return true;
        } else {
            addr = addr & 0x7F;
            this.ram[addr] = value;
            return true;
        }
    }
}

struct TIA {
    func read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
        if !(((_addr & A12) == 0) && ((_addr & A7) == 0)) return (false, -1);

        var addr = _addr;
        addr &= M6507.ADDRESS_BITS;

        var this = cast(*TIA) entry.cbdata;

        addr = addr & 0x0F;

        if (addr > 0xD) return (false, -1);

        // @Incomplete
        return (true, 0);
    }

    func write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
        if !(((_addr & A12) == 0) && ((_addr & A7) == 0)) return false;

        var addr = _addr;
        addr &= M6507.ADDRESS_BITS;

        var this = cast(*TIA) entry.cbdata;

        addr &= 0xFF;

        if (addr >= 0x40) addr -= 0x40;

        if (addr > 0x2C) return false;

        // @Incomplete
        return true;
    }
}

func concat(a: string, b: string) -> string {
    var len = a.length + b.length;
    var o: string;
    o.data = cast() malloc(cast(size_t) len);
    o.length = len;
    memcpy(o.data, a.data, cast(size_t) a.length);
    memcpy(o.data + a.length, b.data, cast(size_t) b.length);
    return o;
}

var step_cpu = false;
func key_callback(window: *GLFWwindow, key: int32, scancode: int32, action: int32, mods: int32) -> void {
    if key == GLFW_KEY_SPACE && (action == 1 || action == 2) {
        step_cpu = true;
    }
}

func main() {
    if glfwInit() != 1 return;

    glfwWindowHint(GLFW_SCALE_TO_MONITOR, 1);

    var window = glfwCreateWindow(640, 480, "a2600", null, null);
    if !window {
        glfwTerminate();
        return;
    }

    glfwMakeContextCurrent(window);

    glfwSetKeyCallback(window, cast() key_callback);

    func get_proc(name: string) -> *void {
        var addr = glfwGetProcAddress(name.data);
        return addr;
    }

    init_gl_functions(get_proc);

    var cpu: M6507;

    var rom_image = read_entire_file("game.bin");

    var cart: Memory_Map_Entry;
    cart.cbdata = *rom_image;
    cart.start = 0x1000;
    cart.end   = 0x1FFF;
    cart.read  = cartridge_read;
    cart.write = cartridge_write;

    cpu.memory.mappings.add(cart);

    var pia: PIA;
    var pia_map: Memory_Map_Entry;
    pia_map.cbdata = *pia;
    pia_map.start = 0x0080;
    pia_map.end   = 0x0FFF;
    pia_map.read  = PIA.read;
    pia_map.write = PIA.write;

    cpu.memory.mappings.add(pia_map);

    var tia: TIA;
    var tia_map: Memory_Map_Entry;
    tia_map.cbdata = *tia;
    tia_map.start = 0x0000;
    tia_map.end   = 0x0F7F;
    tia_map.read  = TIA.read;
    tia_map.write = TIA.write;

    cpu.memory.mappings.add(tia_map);

    var entry_point = cpu.get_word(0xFFFC);
    cpu.PC = entry_point;

    var scanlines = 262; // NTSC, PAL is 312
    var pixels_per_scanline = 228;
    var framebuffer = cast(*uint32) malloc(cast() (scanlines * pixels_per_scanline * sizeof(uint32)));

    var fb_tex: GLuint;
    glGenTextures(1, *fb_tex);
    glBindTexture(GL_TEXTURE_2D, fb_tex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cast() pixels_per_scanline, cast() scanlines, 0, GL_RGBA, GL_UNSIGNED_BYTE, framebuffer);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

    step_cpu = true;
    if step_cpu {
        step_cpu = false;

        while cpu.step() != 0 {

        }
    }

    while !glfwWindowShouldClose(window) {
        glClear(GL_COLOR_BUFFER_BIT);
        glClearColor(0, 0, 0, 1);



        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, fb_tex);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cast() pixels_per_scanline, cast() scanlines, 0, GL_RGBA, GL_UNSIGNED_BYTE, framebuffer); // @Speed

        glBegin(GL_TRIANGLES);
            glTexCoord2f(0, 1);
            glVertex3f(-1, -1, 0);
            glTexCoord2f(1, 1);
            glVertex3f(1, -1, 0);
            glTexCoord2f(1, 0);
            glVertex3f(1, 1, 0);

            glTexCoord2f(1, 0);
            glVertex3f(1, 1, 0);
            glTexCoord2f(0, 0);
            glVertex3f(-1, 1, 0);
            glTexCoord2f(0, 1);
            glVertex3f(-1, -1, 0);
        glEnd();


        glfwPollEvents();
        glfwSwapBuffers(window);
    }

    glfwTerminate();
}