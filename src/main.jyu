#import "LibC";
#import "GLFW";
#import "OpenGL";
#import "Array";

#load "6502.jyu";

#clang_import """

#include "stb_truetype.h"

""";

// #import "Basic"; // assert
// #import "Reference";

operator[] <T, R>(arr: [..] T, index: R) -> T {
    assert(index >= 0 && cast(int64) index < arr.count, "Array index out of range!");
    return arr.data[index];
}

operator[] <T, R>(arr: [] T, index: R) -> T {
    assert(index >= 0 && cast(int64) index < arr.count, "Array index out of range!");
    return arr.data[index];
}

operator[]= <T, R>(arr: [..] T, index: R, value: T) {
    assert(index >= 0 && cast(int64) index < arr.count, "Array index out of range!");
    arr.data[index] = value;
}

operator[]= <T, R>(arr: [] T, index: R, value: T) {
    assert(index >= 0 && cast(int64) index < arr.count, "Array index out of range!");
    arr.data[index] = value;
}

var ttf_buffer : [1<<20] uint8;
var temp_bitmap: [512*512] uint8;

var cdata: [96] stbtt_bakedchar; // ASCII 32..126 is 95 glyphs
var ftex: GLuint;

func my_stbtt_initfont() {
   fread(ttf_buffer.data, 1, 1<<20, fopen("data/Skytree_Mono.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer.data,0, 32.0, temp_bitmap.data,512,512, 32,96, cdata.data); // no guarantee this fits!
   // can free ttf_buffer at this point
   glGenTextures(1, *ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap.data);
   // can free temp_bitmap at this point
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

func my_stbtt_print(_x: float, _y: float, text: string) -> float {
    var x = _x; var y = _y;
    // assume orthographic projection with units = screen pixels, origin at top left
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, ftex);
    glBegin(GL_QUADS);
    for 0..<text.length {
        var ch = text[it];
        if (ch >= 32 && ch < 128) {
            var q: stbtt_aligned_quad;
            stbtt_GetBakedQuad(cdata.data, 512,512, cast(int32) (ch-32), *x,*y,*q,1);//1=opengl & d3d10+,0=d3d9
            glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);
            glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);
            glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);
            glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);
        }
    }
    glEnd();
    return x - _x;
}

let A12 = (1 << 12);
let A9  = (1 << 9);
let A7  = (1 << 7);

func cartridge_read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
    // Cart only accessible if A12 line is 1
    if !(_addr & A12) return (false, -1);

    var addr = _addr;
    var rom = <<cast(*string) entry.cbdata;

    addr &= M6507.ADDRESS_BITS;
    addr -= 0x1000; // map address from 0x1000-0x1FFF to 0x0000-0x0FFF

    if rom.length < 4096 {
        addr %= 2048; // mirror 2k ROM twice across the 4k address range.
    }

    return (true, rom[addr]);
}

func cartridge_write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
    // Cart only accessible if A12 line is 1
    if !(_addr & A12) return false;

    var addr = _addr;
    var rom = <<cast(*string) entry.cbdata;
    addr &= M6507.ADDRESS_BITS;
    addr -= 0x1000; // map address from 0x1000-0x1FFF to 0x0000-0x0FFF

    rom[addr] = value;

    return true;
}

struct PIA {
    var ram: [128] uint8;

    var timer_value  : uint8;
    var timer_ticks  : uint16;
    var timer_divider: uint16 = 1;

    var timXt_regs: [4] uint8;

    var swbcnt: uint8;

    let SWCHA    = 0x280;
    let SWACNT   = 0x281;
    let SWCHB    = 0x282;
    let SWBCNT   = 0x283;
    let INTIM    = 0x284; // @ReadOnly
    let TIM1T    = 0x294;
    let TIM8T    = 0x295;
    let TIM64T   = 0x296;
    let TIM1024T = 0x297;

    func read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
        if !(((_addr & A12) == 0) && ((_addr & A7) != 0)) return (false, -1);

        var addr = _addr;
        addr &= M6507.ADDRESS_BITS;

        var this = cast(*PIA) entry.cbdata;

        if A9 & addr {
            // PIA registers @TODO

            // @Incomplete

            var reg = addr & 0x2FF;

            switch (reg) {
                case INTIM:
                    return (true, this.timer_value);
                case TIM1T, TIM8T, TIM64T, TIM1024T:
                    return (true, this.timXt_regs[reg-TIM1T]);
                case SWCHB:
                    let RESET_BUTTON = (1 << 0); // 0 = pressed @TODO
                    let SELECT_BUTTON = (1 << 1); // 0 = pressed @TODO
                    let COLOR_MODE = (1 << 3); // 0 = Black/White, 1 = Color


                    return (true, (this.swbcnt & 0b110100) | COLOR_MODE | RESET_BUTTON | SELECT_BUTTON);
            }

            return (true, -1);
        } else {
            addr = addr & 0x7F;
            return (true, this.ram[addr]);
        }
    }

    func write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
        // printf("ADDR: %04X\n", _addr);
        if !(((_addr & A12) == 0) && ((_addr & A7) != 0)) return false;

        var addr = _addr;
        addr &= M6507.ADDRESS_BITS;

        var this = cast(*PIA) entry.cbdata;

        if A9 & addr {
            // PIA registers @TODO

            // @Incomplete
            var reg = addr & 0x2FF;

            switch (reg) {
                case INTIM:
                    return true;
                case TIM1T, TIM8T, TIM64T, TIM1024T:
                    this.timXt_regs[reg-TIM1T] = value;

                    this.timer_value = value;
                    this.timer_ticks = 0;

                    if reg == TIM1T {
                        this.timer_divider = 1;
                    } else if reg == TIM8T {
                        this.timer_divider = 8;
                    } else if reg == TIM64T {
                        this.timer_divider = 64;
                    } else if reg == TIM1024T {
                        this.timer_divider = 1024;
                    }
                    return true;
                case SWBCNT:
                    this.swbcnt = value;
                    return true;
            }
            return true;
        } else {
            addr = addr & 0x7F;
            this.ram[addr] = value;
            return true;
        }
    }

    func step(this: *PIA) {
        if (this.timer_ticks % this.timer_divider) == 0 {
            this.timer_value -= 1;
        }

        this.timer_ticks += 1;
        if (this.timer_ticks >= this.timer_divider) this.timer_ticks -= this.timer_divider;
    }
}

struct TIA {
    var framebuffer: [] uint32;
    var current_pixel_clock: uint8;
    var current_scanline: uint16;

    var color_table: [0x10] uint32;

    var write_regs: [0x2D] uint8;

    var vsync_ticker: uint8;

    let WSYNC  = 0x02;

    let VSYNC  = 0x00;
    let VBLANK = 0x01;
    let COLUP0 = 0x06;
    let COLUP1 = 0x07;
    let COLUPF = 0x08;
    let COLUBK = 0x09;
    let CTRLPF = 0x0A;
    let PF0    = 0x0D;
    let PF1    = 0x0E;
    let PF2    = 0x0F;

    func init(this: *TIA) {
        // Taken from the full luminance values from here
        // https://www.biglist.com/lists/stella/archives/200109/msg00285.html

        // NTSC
        // @Cleanup array initializers
        this.color_table[0]  = 0xECECEC;
        this.color_table[1]  = 0xFCFC68;
        this.color_table[2]  = 0xECC878;
        this.color_table[3]  = 0xFCBC94;
        this.color_table[4]  = 0xFCB4B4;
        this.color_table[5]  = 0xECB0E0;
        this.color_table[6]  = 0xD4B0FC;
        this.color_table[7]  = 0xBCB4FC;
        this.color_table[8]  = 0xA4B8FC;
        this.color_table[9]  = 0xA4C8FC;
        this.color_table[10] = 0xA4E0FC;
        this.color_table[11] = 0xA4FCD4;
        this.color_table[12] = 0xB8FCB8;
        this.color_table[13] = 0xC8FCA4;
        this.color_table[14] = 0xE0EC9C;
        this.color_table[15] = 0xFCE08C;
    }

    func calculate_color(this: *TIA, value: uint8) -> uint32 {
        var lum = ((value & 0b1110) >> 1) + 1; // +1 to bring everything just a little off-black
        var lumf = cast(float) lum / 8.0;

        var src = this.color_table[(value & 0xF0) >> 4];

        var a = cast(float) ((src & 0xFF0000) >> 16);
        var b = cast(float) ((src & 0x00FF00) >> 8);
        var c = cast(float) ((src & 0x0000FF) >> 0);

        a *= lumf;
        b *= lumf;
        c *= lumf;

        return (cast(uint32) a << 0) | (cast(uint32) b << 8) | (cast(uint32) c << 16) | 0xFF000000;
    }

    func read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
        if !(((_addr & A12) == 0) && ((_addr & A7) == 0)) return (false, -1);

        var addr = _addr;
        addr &= M6507.ADDRESS_BITS;

        var this = cast(*TIA) entry.cbdata;

        addr = addr & 0x0F;

        if (addr > 0xD) return (false, -1);

        // @Incomplete
        return (true, 0);
    }

    func write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
        if !(((_addr & A12) == 0) && ((_addr & A7) == 0)) return false;

        var addr = _addr;
        addr &= M6507.ADDRESS_BITS;

        var this = cast(*TIA) entry.cbdata;

        addr &= 0xFF;

        if (addr >= 0x40) addr -= 0x40;

        if (addr > 0x2C) return false;

        if addr == WSYNC {
            waiting_for_wsync = true;
        } else if addr == VSYNC {
            if (value & 0b10) this.vsync_ticker = 0;
            // printf("VSYNC\n");
        }

        this.write_regs[addr] = value;
        return true;
    }

    let TOTAL_SCANLINES = 262;
    let HBLANK_PIXELS = 68;
    let PIXELS_PER_SCANLINE = 160;

    func step(this: *TIA) {
        // HBLANK period
        if this.current_pixel_clock < HBLANK_PIXELS {
            this.current_pixel_clock += 1;
            return;
        }

        var current_pixel = this.current_pixel_clock - HBLANK_PIXELS;

        var colubk = calculate_color(this, this.write_regs[COLUBK]);
        var colupf = calculate_color(this, this.write_regs[COLUPF]);
        var colup0 = calculate_color(this, this.write_regs[COLUP0]);
        var colup1 = calculate_color(this, this.write_regs[COLUP1]);
        var color: uint32 = 0xFF000000;

        if !(this.write_regs[VBLANK] & 0b10) {
            color = colubk;

            // Playfield
            var pfpos = (current_pixel / 4) % 20; // 40 dots across the entire scanline, 20 total bits

            var ctrlpf = this.write_regs[CTRLPF];

            if (ctrlpf & 1) != 0 && (current_pixel / 4) >= 20 {
                pfpos = 19 - pfpos;
            }

            if (ctrlpf & 0b10) {
                // score mode
                colupf = colup0;
                if (current_pixel / 4) >= 20 {
                    colupf = colup1;
                }
            }

            if pfpos < 4 {
                var bits = (this.write_regs[PF0] & 0xF0) >> 4;
                if bits & (1 << pfpos) {
                    color = colupf;
                }
            } else if pfpos < 12 {
                pfpos -= 4;
                var bits = this.write_regs[PF1];
                if bits & (1 << (8 - pfpos)) {
                    color = colupf;
                }
            } else {
                pfpos -= 12;
                var bits = this.write_regs[PF2];
                if bits & (1 << pfpos) {
                    color = colupf;
                }
            }
        }

        this.framebuffer[current_pixel + this.current_scanline * PIXELS_PER_SCANLINE] = color;

        this.current_pixel_clock += 1;
        if current_pixel+1 >= PIXELS_PER_SCANLINE {
            waiting_for_wsync = false;
            this.current_pixel_clock = 0;

            this.current_scanline += 1;

            if this.current_scanline >= TOTAL_SCANLINES {
                this.current_scanline = TOTAL_SCANLINES-1;
            }

            if (this.write_regs[VSYNC] & 0b10) {
                if (this.vsync_ticker < 3) this.vsync_ticker += 1;
            } else {
                if this.vsync_ticker >= 3 {
                    this.current_scanline = 0;
                    this.vsync_ticker = 0;
                    vsync_triggered = true;
                }
            }
        }
    }
}

func concat(a: string, b: string) -> string {
    var len = a.length + b.length;
    var o: string;
    o.data = cast() malloc(cast(size_t) len);
    o.length = len;
    memcpy(o.data, a.data, cast(size_t) a.length);
    memcpy(o.data + a.length, b.data, cast(size_t) b.length);
    return o;
}

var step_cpu = false;
func key_callback(window: *GLFWwindow, key: int32, scancode: int32, action: int32, mods: int32) -> void {
    if key == GLFW_KEY_SPACE && (action == 1 || action == 2) {
        step_cpu = true;
    }
}

func debug_func (source: GLenum, type: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: *GLchar, userParam: *void) -> void {
    printf("Message: %s\n", message);
    assert(false);
}

var waiting_for_wsync = false;
var vsync_triggered = false;
var single_step = false;

func main(argc: int32, argv: **uint8) {
    if (argc < 2) {
        printf("Please provide a path to a ROM file to run!\n");
        return;
    }
    var rom_image = read_entire_file(to_string(argv[1]));

    if true {
        var exe_path = get_executable_path();
        printf("Exe path: '%.*s'\n", exe_path.length, exe_path.data);
        set_working_directory(basename(exe_path));
    }

    if glfwInit() != 1 return;

    glfwWindowHint(GLFW_SCALE_TO_MONITOR, 1);

    var window = glfwCreateWindow(1280, 720, "U0VDUkVUIFBST0pFQ1QgRE8gTk9UIExFQUs=", null, null);
    if !window {
        glfwTerminate();
        return;
    }

    glfwMakeContextCurrent(window);

    glfwSetKeyCallback(window, cast() key_callback);

    func get_proc(name: string) -> *void {
        var addr = glfwGetProcAddress(name.data);
        return addr;
    }

    init_gl_functions(get_proc);

    glEnable(GL_FRAMEBUFFER_SRGB);

    glDebugMessageCallback(cast() debug_func, null);
    glEnable(GL_DEBUG_OUTPUT);

    var cpu: M6507;

    var cart: Memory_Map_Entry;
    cart.cbdata = *rom_image;
    cart.start = 0x1000;
    cart.end   = 0x1FFF;
    cart.read  = cartridge_read;
    cart.write = cartridge_write;

    cpu.memory.mappings.add(cart);

    var pia: PIA;
    var pia_map: Memory_Map_Entry;
    pia_map.cbdata = *pia;
    pia_map.start = 0x0080;
    pia_map.end   = 0x0FFF;
    pia_map.read  = PIA.read;
    pia_map.write = PIA.write;

    cpu.memory.mappings.add(pia_map);

    var tia: TIA;
    tia.init();
    var tia_map: Memory_Map_Entry;
    tia_map.cbdata = *tia;
    tia_map.start = 0x0000;
    tia_map.end   = 0x0F7F;
    tia_map.read  = TIA.read;
    tia_map.write = TIA.write;

    cpu.memory.mappings.add(tia_map);

    var entry_point = cpu.get_word(0xFFFC);
    cpu.PC = entry_point;

    var scanlines = TIA.TOTAL_SCANLINES; // NTSC, PAL is 312
    var pixels_per_scanline = TIA.PIXELS_PER_SCANLINE;
    var framebuffer = cast(*uint32) malloc(cast() (scanlines * pixels_per_scanline * sizeof(uint32)));
    tia.framebuffer.data  = framebuffer;
    tia.framebuffer.count = scanlines * pixels_per_scanline;

    var fb_tex: GLuint;
    glGenTextures(1, *fb_tex);
    glBindTexture(GL_TEXTURE_2D, fb_tex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cast() pixels_per_scanline, cast() scanlines, 0, GL_RGBA, GL_UNSIGNED_BYTE, framebuffer);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

    my_stbtt_initfont();

    // glDisable(GL_CULL_FACE);

    step_cpu = true;

    while !glfwWindowShouldClose(window) {
        glClear(GL_COLOR_BUFFER_BIT);
        glClearColor(0.2, 0.2, 0.2, 1);


        if step_cpu {
            if single_step step_cpu = false;
            while !vsync_triggered {
                var clks = 1;
                if !waiting_for_wsync {
                    clks = cpu.step();
                    
                    for 0..<clks {
                        pia.step();
                    }
                }

                if clks == 0 {
                    step_cpu = false;
                }

                

                for 0..<clks {
                    tia.step();
                    tia.step();
                    tia.step();
                }

                if single_step break;
            }

            vsync_triggered = false;
        }

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        var width: int32;
        var height: int32;
        glfwGetWindowSize(window, *width, *height);

        var xscale: float = 1;
        var yscale: float = 1;

        // @TODO I am not sure what is the best thing to do on Windows/Linux
        // Using this on Windows seems to mess up rendering in that nothing gets drawn..
        #if os(MacOSX) {
            glfwGetWindowContentScale(window, *xscale, *yscale);
        }

        glViewport(0, 0, cast(GLsizei) (width * xscale), cast(GLsizei) (height * yscale));
        glOrtho(0, width*xscale, height*yscale, 0, -1, 1);

        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, fb_tex);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cast() pixels_per_scanline, cast() scanlines, 0, GL_RGBA, GL_UNSIGNED_BYTE, framebuffer); // @Speed

        let scale = 3;
        var playfield_width: float = pixels_per_scanline * scale;
        var playfield_height: float = scanlines * scale;
        {
            var x: float = 0;
            var y: float = 0;
            var width = playfield_width;
            var height = playfield_height;

            glBegin(GL_TRIANGLES);
                glTexCoord2f(0, 0);
                glVertex3f(x, y, 0);
                glTexCoord2f(1, 0);
                glVertex3f(x+width, y, 0);
                glTexCoord2f(1, 1);
                glVertex3f(x+width, y+height, 0);

                glTexCoord2f(1, 1);
                glVertex3f(x+width, y+height, 0);
                glTexCoord2f(0, 1);
                glVertex3f(x, y+height, 0);
                glTexCoord2f(0, 0);
                glVertex3f(x, y, 0);
            glEnd();
        }

        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_TEXTURE_2D);

        var text_height: float = 32;
        var y_offset: float;
        var x_offset: float;
        for pia.ram {
            if (it_index % 16) == 0 && it_index != 0 {
                x_offset = 0;
                y_offset += 32;
            }

            var buf: [4] uint8;
            snprintf(buf.data, cast() buf.count, "%02X ", it);
            var width = my_stbtt_print(playfield_width + x_offset, y_offset + text_height, to_string(buf.data));
            x_offset += width;
        }

        y_offset += text_height;

        var buf: [32] uint8;
        snprintf(buf.data, buf.count, "X: %02X", cpu.regs[M6507.REG_X]);
        my_stbtt_print(playfield_width, y_offset + text_height*1, to_string(buf.data));


        snprintf(buf.data, buf.count, "Y: %02X", cpu.regs[M6507.REG_Y]);
        my_stbtt_print(playfield_width, y_offset + text_height*2, to_string(buf.data));

        snprintf(buf.data, buf.count, "A: %02X", cpu.regs[M6507.REG_A]);
        my_stbtt_print(playfield_width, y_offset + text_height*3, to_string(buf.data));

        snprintf(buf.data, buf.count, "S: %02X", cpu.regs[M6507.REG_S]);
        my_stbtt_print(playfield_width, y_offset + text_height*4, to_string(buf.data));

        snprintf(buf.data, buf.count, "P: %02X", cpu.P);
        my_stbtt_print(playfield_width, y_offset + text_height*5, to_string(buf.data));

        snprintf(buf.data, buf.count, "PC: %04X", cpu.PC);
        my_stbtt_print(playfield_width, y_offset + text_height*6, to_string(buf.data));

        y_offset += text_height*6;

        snprintf(buf.data, buf.count, "PF0: %02X", tia.write_regs[TIA.PF0]);
        my_stbtt_print(playfield_width, y_offset + text_height*1, to_string(buf.data));
        snprintf(buf.data, buf.count, "PF1: %02X", tia.write_regs[TIA.PF1]);
        my_stbtt_print(playfield_width, y_offset + text_height*2, to_string(buf.data));
        snprintf(buf.data, buf.count, "PF2: %02X", tia.write_regs[TIA.PF2]);
        my_stbtt_print(playfield_width, y_offset + text_height*3, to_string(buf.data));

        snprintf(buf.data, buf.count, "COLUPF: %02X", tia.write_regs[TIA.COLUPF]);
        my_stbtt_print(playfield_width, y_offset + text_height*4, to_string(buf.data));
        snprintf(buf.data, buf.count, "COLUBK: %02X", tia.write_regs[TIA.COLUBK]);
        my_stbtt_print(playfield_width, y_offset + text_height*5, to_string(buf.data));

        snprintf(buf.data, buf.count, "CTRLPF: %02X", tia.write_regs[TIA.CTRLPF]);
        my_stbtt_print(playfield_width, y_offset + text_height*6, to_string(buf.data));

        snprintf(buf.data, buf.count, "COMBAT SCANLINE: %02X", cpu.get_byte(0xB4));
        my_stbtt_print(playfield_width, y_offset + text_height*7, to_string(buf.data));

        glDisable(GL_BLEND);

        glfwPollEvents();
        glfwSwapBuffers(window);
    }

    glfwTerminate();
}