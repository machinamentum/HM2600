#import "LibC";
#import "GLFW";
#import "OpenGL";
#import "Array";

#load "6502.jyu";

// #clang_import """
// #include "stb_truetype.h"
// """;

#import "UI";
#import "UI_GL_Renderer";

// @Cleanup once we have namespaces
// @FixMe ma_device seems to be causing some data overrun....
// due to a compiler bug..
struct MA_Device_Hack {
    var device: Mini_Audio.ma_device;
    var _device_buffer: [1 << 20] uint8; // @Hack inserted here to to catch the overrun
}

var ma_device_hack: MA_Device_Hack;

struct Mini_Audio {
    #clang_import """
    #include "miniaudio.h"
    """;

    let MA_SUCCESS = 0;

    func _4bitpoly(old: uint8) -> (hi: bool, new: uint8) {
        var c = (old & 0b0010) >> 1;
        var d = old & 0b0001;

        var value = old;
        value = value >> 1;

        value |= ((c^d) << 3);

        return (d != 0, value);
    }

    func _5bitpoly(old: uint8) -> (hi: bool, new: uint8) {
        var c = (old & 0b00100) >> 2;
        var e = old & 0b0001;

        var value = old;
        value = value >> 1;

        value |= ((c^e) << 4);

        return (e != 0, value);
    }

    func _9bitpoly(old: uint16) -> (hi: bool, new: uint16) {
        var e = (old & 0b000010000) >> 4;
        var i =  old & 0b000000001;

        var value = old;
        value = value >> 1;

        value |= ((e^i) << 8);

        return (i != 0, value);
    }

    func data_callback(pDevice: *ma_device, pOutput: *void, pInput: *void, frameCount: ma_uint32) {
        var tia = cast(*TIA) pDevice.pUserData;
        var out = cast(*int16) pOutput;

        var vol0 = tia.write_regs[TIA.AUDV0] & 0x0F;
        var vol1 = tia.write_regs[TIA.AUDV1] & 0x0F;

        var div0 = (tia.write_regs[TIA.AUDF0] & 0x1F) + 1;
        var div1 = (tia.write_regs[TIA.AUDF1] & 0x1F) + 1;

        var ctrl0 = tia.write_regs[TIA.AUDC0] & 0x0F;
        var ctrl1 = tia.write_regs[TIA.AUDC1] & 0x0F;

        let high: int16 =  32767;
        let low : int16 = -32767;

        var pure_hi: [2] bool;

        // printf("V0: %X, D0: %d, C0: %d\n", vol0, div0, ctrl0);
        // printf("V1: %X, D1: %d, C1: %d\n", vol1, div1, ctrl1);

        for 0..<frameCount {
            
            var tick1 = (it % div1 == 0);

            func calc(tia: *TIA, ticks: uint32, div: uint8, _vol: uint8, ctrl: uint8, pure_state: *bool, index: uint8) -> int16 {
                var tick = (ticks % div == 0);
                var vol = _vol;
                var value: int16;
                if vol > 0 && ctrl > 0 {
                    if ctrl == 7 || ctrl == 9 {
                        var poly = _5bitpoly(tia._5bitpoly[index]);
                        if tick
                            tia._5bitpoly[index] = poly.new;

                        if poly.hi {
                            value = high;
                        } else {
                            value = low;
                        }
                    } else if ctrl == 3 {
                        var poly = _5bitpoly(tia._5bitpoly[index]);
                        tia._5bitpoly[index] = poly.new;

                        if poly.hi {
                            poly = _4bitpoly(tia._4bitpoly[index]);
                            if tick
                                tia._4bitpoly[index] = poly.new;

                            if poly.hi {
                                value = high;
                            } else {
                                value = low;
                            }
                        }
                    } else if ctrl == 1 {
                        var poly = _4bitpoly(tia._4bitpoly[index]);
                        if tick
                            tia._4bitpoly[index] = poly.new;

                        if poly.hi {
                            value = high;
                        } else {
                            value = low;
                        }
                    } else if ctrl == 8 {
                        var poly = _9bitpoly(tia._9bitpoly[index]);
                        if tick
                            tia._9bitpoly[index] = poly.new;

                        if poly.hi {
                            value = high;
                        } else {
                            value = low;
                        }
                    } else {
                            if tick {
                                (<<pure_state) = !(<<pure_state);
                            }

                            if (<<pure_state) {
                                value = high;
                            } else {
                                value = low;
                            }
                    }

                    vol = 16-vol;
                    value /= cast(int16) vol;
                }

                return value;
            }

            var value0 = calc(tia, it, div0, vol0, ctrl0, *pure_hi.data[0], 0);
            var value1 = calc(tia, it, div1, vol1, ctrl1, *pure_hi.data[1], 0);

            out[it] = (value0 + value1) / 2;
        }
    }

    func init_audio(tia: *TIA) {
        var config = ma_device_config_init(ma_device_type_playback);
        config.playback.format   = ma_format_s16;
        config.playback.channels = 1;
        config.sampleRate        = 31399;
        config.dataCallback      = cast() data_callback;
        config.pUserData         = tia;

        if (ma_device_init(null, *config, *ma_device_hack.device) != MA_SUCCESS) {
          printf("Could not create audio device.\n");
        }

        ma_device_start(*ma_device_hack.device);     // The device is sleeping by default so you'll need to start it manually.
    }

    func stop_audio() {
        ma_device_uninit(*ma_device_hack.device);    // This will stop the device so no need to do that manually.
    }
}

operator[] <T, R>(arr: [] T, index: R) -> T {
    assert(index >= 0 && cast(int64) index < arr.count, "Array index out of range!");
    return arr.data[index];
}

operator[]= <T, R>(arr: [] T, index: R, value: T) {
    assert(index >= 0 && cast(int64) index < arr.count, "Array index out of range!");
    arr.data[index] = value;
}

let A12 = (1 << 12);
let A9  = (1 << 9);
let A7  = (1 << 7);

func cartridge_read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
    // Cart only accessible if A12 line is 1
    if !(_addr & A12) return (false, -1);

    var addr = _addr;
    var rom = <<cast(*string) entry.cbdata;

    addr -= 0x1000; // map address from 0x1000-0x1FFF to 0x0000-0x0FFF

    if rom.length < 4096 {
        addr %= 2048; // mirror 2k ROM twice across the 4k address range.
    }

    return (true, rom[addr]);
}

func cartridge_write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
    // Cart only accessible if A12 line is 1
    if !(_addr & A12) return false;

    var addr = _addr;
    var rom = <<cast(*string) entry.cbdata;
    addr -= 0x1000; // map address from 0x1000-0x1FFF to 0x0000-0x0FFF

    rom[addr] = value;

    return true;
}

struct PIA {
    var ram: [128] uint8;

    var timer_value  : uint8;
    var timer_ticks  : uint16;
    var timer_divider: uint16 = 1;
    var timer_did_underflow = false;

    var instat: uint8;
    var timXt_regs: [4] uint8;

    var swbcnt: uint8;

    let SWCHA    = 0x280;
    let SWACNT   = 0x281;
    let SWCHB    = 0x282;
    let SWBCNT   = 0x283;
    let INTIM    = 0x284; // @ReadOnly
    let INSTAT   = 0x285; // @ReadOnly
    let TIM1T    = 0x294;
    let TIM8T    = 0x295;
    let TIM64T   = 0x296;
    let TIM1024T = 0x297;

    func read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
        if !(((_addr & A12) == 0) && ((_addr & A7) != 0)) return (false, -1);

        var addr = _addr;

        var this = cast(*PIA) entry.cbdata;

        // if addr > 0x200 && addr != 0x284 printf("ADDR: %04X\n", addr);

        if A9 & addr {
            // PIA registers @TODO

            // @Incomplete

            var reg = addr & 0x2FF;

            switch (reg) {
                case INSTAT:
                    return (true, this.instat);
                case INTIM:
                    this.timer_did_underflow = false;
                    this.instat &= cast(uint8) ~(1 << 6);
                    return (true, this.timer_value);
                case TIM1T, TIM8T, TIM64T, TIM1024T:
                    return (true, this.timXt_regs[reg-TIM1T]);
                case SWCHA:
                    var flags: uint8 = 0xFF;
                    if joy0_up_held    flags &= cast(uint8)~(1 << 4);
                    if joy0_down_held  flags &= cast(uint8)~(1 << 5);
                    if joy0_left_held  flags &= cast(uint8)~(1 << 6);
                    if joy0_right_held flags &= cast(uint8)~(1 << 7);
                    return (true, flags | 0x0F);
                case SWCHB:
                    let RESET_BUTTON  = (1 << 0); // 0 = pressed
                    let SELECT_BUTTON = (1 << 1); // 0 = pressed
                    let COLOR_MODE    = (1 << 3); // 0 = Black/White, 1 = Color

                    var reset : uint8 = RESET_BUTTON;
                    var select: uint8 = SELECT_BUTTON;
                    if reset_held  reset = 0;
                    if select_held select = 0;

                    return (true, (this.swbcnt & 0b110100) | COLOR_MODE | reset | select);
            }

            printf("ADDR: %04X\n", reg);

            return (true, -1);
        } else {
            addr = addr & 0x7F;
            return (true, this.ram[addr]);
        }
    }

    func write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
        // printf("ADDR: %04X\n", _addr);
        if !(((_addr & A12) == 0) && ((_addr & A7) != 0)) return false;

        var addr = _addr;

        var this = cast(*PIA) entry.cbdata;

        if A9 & addr {
            // PIA registers @TODO

            // @Incomplete
            var reg = addr & 0x2FF;

            switch (reg) {
                case INTIM:
                    return true;
                case TIM1T, TIM8T, TIM64T, TIM1024T:
                    this.instat &= cast(uint8) ~(1 << 7);

                    this.timXt_regs[reg-TIM1T] = value;

                    this.timer_value = value;
                    this.timer_ticks = 0;
                    this.timer_did_underflow = false;
                    this.instat &= cast(uint8) ~(1 << 7);

                    if reg == TIM1T {
                        this.timer_divider = 1;
                    } else if reg == TIM8T {
                        this.timer_divider = 8;
                    } else if reg == TIM64T {
                        this.timer_divider = 64;
                    } else if reg == TIM1024T {
                        this.timer_divider = 1024;
                    }
                    return true;
                case SWBCNT:
                    this.swbcnt = value;
                    return true;
            }
            return true;
        } else {
            addr = addr & 0x7F;
            this.ram[addr] = value;
            return true;
        }
    }

    func step(this: *PIA) {
        if this.timer_did_underflow {
            this.timer_value -= 1;
        } else {
            if (this.timer_ticks % this.timer_divider) == 0 {
                this.timer_value -= 1;

                if this.timer_value == 0xFF {
                    this.timer_did_underflow = true;
                    this.instat = 0b11000000;
                }
            }
        }

        this.timer_ticks += 1;
        if (this.timer_ticks >= this.timer_divider) this.timer_ticks -= this.timer_divider;
    }
}

struct TIA {
    var framebuffer: [] uint32;
    var current_pixel_clock: uint8;
    var current_scanline: uint16;

    var color_table: [0x8][0x10] uint32;

    var write_regs: [0x2D] uint8;
    var collision_latches: [8] uint8;

    var vsync_ticker: uint8;

    var player_pos : [2] uint8;
    var missile_pos: [2] uint8;
    var ball_pos   : uint8;

    var delay_grp0: uint8 = 0xFF;
    var delay_grp1: uint8 = 0xFF;
    var delay_enabl: uint8 = 0xFF;

    var hmove_in_hblank: uint8;

    var _4bitpoly: [2] uint8;
    var _5bitpoly: [2] uint8;
    var _9bitpoly: [2] uint16;

    // var resp0: uint8 = -1;
    // var resp1: uint8 = -1;


    let VSYNC  = 0x00;
    let VBLANK = 0x01;
    let WSYNC  = 0x02;
    let RSYNC  = 0x03;

    let NUSIZ0 = 0x04;
    let NUSIZ1 = 0x05;
    let COLUP0 = 0x06;
    let COLUP1 = 0x07;
    let COLUPF = 0x08;
    let COLUBK = 0x09;
    let CTRLPF = 0x0A;
    let REFP0  = 0x0B;
    let REFP1  = 0x0C;
    let PF0    = 0x0D;
    let PF1    = 0x0E;
    let PF2    = 0x0F;
    let RESP0  = 0x10;
    let RESP1  = 0x11;
    let RESM0  = 0x12;
    let RESM1  = 0x13;
    let RESBL  = 0x14;

    let AUDC0  = 0x15;
    let AUDC1  = 0x16;
    let AUDF0  = 0x17;
    let AUDF1  = 0x18;
    let AUDV0  = 0x19;
    let AUDV1  = 0x1A;

    let GRP0   = 0x1B;
    let GRP1   = 0x1C;
    let ENAM0  = 0x1D;
    let ENAM1  = 0x1E;
    let ENABL  = 0x1F;
    let HMP0   = 0x20;
    let HMP1   = 0x21;
    let HMM0   = 0x22;
    let HMM1   = 0x23;
    let HMBL   = 0x24;
    let VDELP0 = 0x25;
    let VDELP1 = 0x26;
    let VDELBL = 0x27;
    let RESMP0 = 0x28;
    let RESMP1 = 0x29;

    let HMOVE  = 0x2A;
    let HMCLR  = 0x2B;
    let CXCLR  = 0x2C;

    let CXM0P  = 0x30;
    let CXM1P  = 0x31;
    let CXP0FB = 0x32;
    let CXP1FB = 0x33;
    let CXM0FB = 0x34;
    let CXM1FB = 0x35;
    let CXBLPF = 0x36;
    let CXPPMM = 0x37;

    let INPT0  = 0x38;
    let INPT1  = 0x39;
    let INPT2  = 0x3A;
    let INPT3  = 0x3B;
    let INPT4  = 0x3C;
    let INPT5  = 0x3D;

    func init(this: *TIA) {
        for *this._4bitpoly {
            <<it = 0xFF;
        }

        for *this._5bitpoly {
            <<it = 0xFF;
        }

        for *this._9bitpoly {
            <<it = 0xFFFF;
        }
        // Taken from
        // http://www.qotile.net/minidig/docs/tia_color.html

        // NTSC
        // @Cleanup array initializers
        // Using .data here to avoid operator[] from overloading
        this.color_table.data[0][0] = 0x000000;
        this.color_table.data[0][1] = 0x444400;
        this.color_table.data[0][2] = 0x702800;
        this.color_table.data[0][3] = 0x841800;
        this.color_table.data[0][4] = 0x880000;
        this.color_table.data[0][5] = 0x78005C;
        this.color_table.data[0][6] = 0x480078;
        this.color_table.data[0][7] = 0x140084;
        this.color_table.data[0][8] = 0x000088;
        this.color_table.data[0][9] = 0x00187C;
        this.color_table.data[0][10] = 0x002C5C;
        this.color_table.data[0][11] = 0x003C2C;
        this.color_table.data[0][12] = 0x003C00;
        this.color_table.data[0][13] = 0x143800;
        this.color_table.data[0][14] = 0x2C3000;
        this.color_table.data[0][15] = 0x442800;

        this.color_table.data[1][0] = 0x404040;
        this.color_table.data[1][1] = 0x646410;
        this.color_table.data[1][2] = 0x844414;
        this.color_table.data[1][3] = 0x983418;
        this.color_table.data[1][4] = 0x9C2020;
        this.color_table.data[1][5] = 0x8C2074;
        this.color_table.data[1][6] = 0x602090;
        this.color_table.data[1][7] = 0x302098;
        this.color_table.data[1][8] = 0x1C209C;
        this.color_table.data[1][9] = 0x1C3890;
        this.color_table.data[1][10] = 0x1C4C78;
        this.color_table.data[1][11] = 0x1C5C48;
        this.color_table.data[1][12] = 0x205C20;
        this.color_table.data[1][13] = 0x345C1C;
        this.color_table.data[1][14] = 0x4C501C;
        this.color_table.data[1][15] = 0x644818;

        this.color_table.data[2][0] = 0x6C6C6C;
        this.color_table.data[2][1] = 0x848424;
        this.color_table.data[2][2] = 0x985C28;
        this.color_table.data[2][3] = 0xAC5030;
        this.color_table.data[2][4] = 0xB03C3C;
        this.color_table.data[2][5] = 0xA03C88;
        this.color_table.data[2][6] = 0x783CA4;
        this.color_table.data[2][7] = 0x4C3CAC;
        this.color_table.data[2][8] = 0x3840B0;
        this.color_table.data[2][9] = 0x3854A8;
        this.color_table.data[2][10] = 0x386890;
        this.color_table.data[2][11] = 0x387C64;
        this.color_table.data[2][12] = 0x407C40;
        this.color_table.data[2][13] = 0x507C38;
        this.color_table.data[2][14] = 0x687034;
        this.color_table.data[2][15] = 0x846830;

        this.color_table.data[3][0] = 0x909090;
        this.color_table.data[3][1] = 0xA0A034;
        this.color_table.data[3][2] = 0xAC783C;
        this.color_table.data[3][3] = 0xC06848;
        this.color_table.data[3][4] = 0xC05858;
        this.color_table.data[3][5] = 0xB0589C;
        this.color_table.data[3][6] = 0x8C58B8;
        this.color_table.data[3][7] = 0x6858C0;
        this.color_table.data[3][8] = 0x505CC0;
        this.color_table.data[3][9] = 0x5070BC;
        this.color_table.data[3][10] = 0x5084AC;
        this.color_table.data[3][11] = 0x509C80;
        this.color_table.data[3][12] = 0x5C9C5C;
        this.color_table.data[3][13] = 0x6C9850;
        this.color_table.data[3][14] = 0x848C4C;
        this.color_table.data[3][15] = 0xA08444;

        this.color_table.data[4][0] = 0xB0B0B0;
        this.color_table.data[4][1] = 0xB8B840;
        this.color_table.data[4][2] = 0xBC8C4C;
        this.color_table.data[4][3] = 0xD0805C;
        this.color_table.data[4][4] = 0xD07070;
        this.color_table.data[4][5] = 0xC070B0;
        this.color_table.data[4][6] = 0xA070CC;
        this.color_table.data[4][7] = 0x7C70D0;
        this.color_table.data[4][8] = 0x6874D0;
        this.color_table.data[4][9] = 0x6888CC;
        this.color_table.data[4][10] = 0x689CC0;
        this.color_table.data[4][11] = 0x68B494;
        this.color_table.data[4][12] = 0x74B474;
        this.color_table.data[4][13] = 0x84B468;
        this.color_table.data[4][14] = 0x9CA864;
        this.color_table.data[4][15] = 0xB89C58;

        this.color_table.data[5][0] = 0xC8C8C8;
        this.color_table.data[5][1] = 0xD0D050;
        this.color_table.data[5][2] = 0xCCA05C;
        this.color_table.data[5][3] = 0xE09470;
        this.color_table.data[5][4] = 0xE08888;
        this.color_table.data[5][5] = 0xD084C0;
        this.color_table.data[5][6] = 0xB484DC;
        this.color_table.data[5][7] = 0x9488E0;
        this.color_table.data[5][8] = 0x7C8CE0;
        this.color_table.data[5][9] = 0x7C9CDC;
        this.color_table.data[5][10] = 0x7CB4D4;
        this.color_table.data[5][11] = 0x7CD0AC;
        this.color_table.data[5][12] = 0x8CD08C;
        this.color_table.data[5][13] = 0x9CCC7C;
        this.color_table.data[5][14] = 0xB4C078;
        this.color_table.data[5][15] = 0xD0B46C;

        this.color_table.data[6][0] = 0xDCDCDC;
        this.color_table.data[6][1] = 0xE8E85C;
        this.color_table.data[6][2] = 0xDCB468;
        this.color_table.data[6][3] = 0xECA880;
        this.color_table.data[6][4] = 0xECA0A0;
        this.color_table.data[6][5] = 0xDC9CD0;
        this.color_table.data[6][6] = 0xC49CEC;
        this.color_table.data[6][7] = 0xA8A0EC;
        this.color_table.data[6][8] = 0x90A4EC;
        this.color_table.data[6][9] = 0x90B4EC;
        this.color_table.data[6][10] = 0x90CCE8;
        this.color_table.data[6][11] = 0x90E4C0;
        this.color_table.data[6][12] = 0xA4E4A4;
        this.color_table.data[6][13] = 0xB4E490;
        this.color_table.data[6][14] = 0xCCD488;
        this.color_table.data[6][15] = 0xE8CC7C;

        this.color_table.data[7][0]  = 0xECECEC;
        this.color_table.data[7][1]  = 0xFCFC68;
        this.color_table.data[7][2]  = 0xECC878;
        this.color_table.data[7][3]  = 0xFCBC94;
        this.color_table.data[7][4]  = 0xFCB4B4;
        this.color_table.data[7][5]  = 0xECB0E0;
        this.color_table.data[7][6]  = 0xD4B0FC;
        this.color_table.data[7][7]  = 0xBCB4FC;
        this.color_table.data[7][8]  = 0xA4B8FC;
        this.color_table.data[7][9]  = 0xA4C8FC;
        this.color_table.data[7][10] = 0xA4E0FC;
        this.color_table.data[7][11] = 0xA4FCD4;
        this.color_table.data[7][12] = 0xB8FCB8;
        this.color_table.data[7][13] = 0xC8FCA4;
        this.color_table.data[7][14] = 0xE0EC9C;
        this.color_table.data[7][15] = 0xFCE08C;
    }

    func calculate_color(this: *TIA, value: uint8) -> uint32 {
        var lum = ((value & 0b1110) >> 1);
        var col = ((value & 0xF0)   >> 4);
        
        var color = this.color_table.data[lum][col];

        var a = (color & 0xFF0000) >> 16;
        var b = (color & 0x00FF00) >> 8;
        var c = (color & 0x0000FF);

        return a | b << 8 | c << 16 | 0xFF000000;
    }

    func read(entry: *Memory_Map_Entry, _addr: uint16) -> (handled: bool, value: uint8) {
        if !(((_addr & A12) == 0) && ((_addr & A7) == 0)) return (false, -1);

        var addr = _addr;

        var this = cast(*TIA) entry.cbdata;

        addr = addr & 0x0F;

        if (addr > 0xD) return (false, -1);

        addr |= 0x30;

        if addr >= INPT0 && addr <= INPT3 {
            if this.write_regs[VBLANK] & (1 << 7) {
                return (true, 0);
            }
        }

        if addr == INPT0 {

        } else if addr == INPT1 {

        } else if addr == INPT2 {
            
        } else if addr == INPT3 {

        } else if addr == INPT4 {
            var fire: uint8 = 1 << 7;
            if joy0_fire_held fire = 0;
            return (true, fire | 0x7F); // @Incomplete
        } else if addr == INPT5 {
            return (true, 0xFF); // @Incomplete
        } else if addr >= CXM0P && addr <= CXPPMM {
            return (true, this.collision_latches[addr-CXM0P]);
        }

        // @Incomplete
        return (true, 0);
    }

    func write(entry: *Memory_Map_Entry, _addr: uint16, value: uint8) -> bool {
        if !(((_addr & A12) == 0) && ((_addr & A7) == 0)) return false;

        var addr = _addr;

        var this = cast(*TIA) entry.cbdata;

        addr &= 0xFF;

        if (addr >= 0x40) addr -= 0x40;

        if (addr > 0x2C) return false;

        if addr == WSYNC {
            waiting_for_wsync = true;
        } else if addr == VSYNC {

            if (value & 0b10) {
                this.vsync_ticker += 1;
            }
        } else if addr == HMOVE {
            // printf("HMM0: %02X\n", HMM0);
            // printf("HMM1: %02X\n", HMM1);
            // printf("HMP0: %02X\n", HMP0);
            // printf("HMP1: %02X\n", HMP1);
            // printf("ASDASD p0pos: %d\n", this.player_pos[0]);
            // printf("DIFF: %d\n", cast(int32) (cast(int8) this.write_regs[HMP0] >> 4));

            var missile_pos0 = (cast(int16) cast(uint16) this.missile_pos[0] - (cast(int16) (cast(int8) this.write_regs[HMM0] >> 4))) % 160;
            if missile_pos0 < 0 missile_pos0 += 160;
            var missile_pos1 = (cast(int16) cast(uint16) this.missile_pos[1] - (cast(int16) (cast(int8) this.write_regs[HMM1] >> 4))) % 160;
            if missile_pos1 < 0 missile_pos1 += 160;

            var player_pos0  = (cast(int16) cast(uint16) this.player_pos[0]  - (cast(int16) (cast(int8) this.write_regs[HMP0] >> 4))) % 160;
            if player_pos0 < 0 player_pos0 += 160;
            var player_pos1  = (cast(int16) cast(uint16) this.player_pos[1]  - (cast(int16) (cast(int8) this.write_regs[HMP1] >> 4))) % 160;
            if player_pos1 < 0 player_pos1 += 160;

            var ball_pos     = (cast(int16) cast(uint16) this.ball_pos       - (cast(int16) (cast(int8) this.write_regs[HMBL] >> 4))) % 160;
            if ball_pos < 0 ball_pos += 160;

            assert(missile_pos0 >= 0 && missile_pos0 < 160);
            assert(missile_pos1 >= 0 && missile_pos1 < 160);
            assert(player_pos0 >= 0 && player_pos0 < 160);
            assert(player_pos1 >= 0 && player_pos1 < 160);
            assert(ball_pos >= 0 && ball_pos < 160);

            this.missile_pos[0] = cast(uint8) missile_pos0;
            this.missile_pos[1] = cast(uint8) missile_pos1;
            this.player_pos[0] = cast(uint8) player_pos0;
            this.player_pos[1] = cast(uint8) player_pos1;
            this.ball_pos = cast(uint8) ball_pos;

            if this.current_pixel_clock < HBLANK_PIXELS {
                this.hmove_in_hblank = 8;
            }
        } else if addr == RESP0 || addr == RESP1 {
            this.player_pos[addr-RESP0] = (this.current_pixel_clock - HBLANK_PIXELS) + 5; // @Hack I chose these numbers based on what I was seeing in various games. I do not know why the sprites are off by these amounts, it could be a timing issue or we are missing CPU clocks or something.
            if this.current_pixel_clock < HBLANK_PIXELS this.player_pos[addr-RESP0] = 0;
        } else if addr == RESM0 || addr == RESM1 {
            this.missile_pos[addr-RESM0] = (this.current_pixel_clock - HBLANK_PIXELS) + 5; // @Hack I chose these numbers based on what I was seeing in various games. I do not know why the sprites are off by these amounts, it could be a timing issue or we are missing CPU clocks or something.
            if this.current_pixel_clock < HBLANK_PIXELS this.missile_pos[addr-RESM0] = 0;
        } else if addr == RESBL {
            this.ball_pos = (this.current_pixel_clock - HBLANK_PIXELS) + 4; // @Hack I chose these numbers based on what I was seeing in various games. I do not know why the sprites are off by these amounts, it could be a timing issue or we are missing CPU clocks or something.
            if this.current_pixel_clock < HBLANK_PIXELS this.ball_pos = HBLANK_PIXELS + 0;
        } else if addr == HMCLR {
            for HMP0..HMBL {
                this.write_regs[it] = 0;
            }
        } else if addr == RESMP0 {
            var shape = this.write_regs[NUSIZ0] & 0b111;
            this.missile_pos[0] = this.player_pos[0] + 3;

            if shape == 5 this.missile_pos[0] += 3;
            if shape == 7 this.missile_pos[0] += 7;
        } else if addr == RESMP1 {
            var shape = this.write_regs[NUSIZ1] & 0b111;
            this.missile_pos[1] = this.player_pos[1] + 3;

            if shape == 5 this.missile_pos[1] += 3;
            if shape == 7 this.missile_pos[1] += 7;
        } else if addr == CXCLR {
            for CXM0P..CXPPMM {
                this.collision_latches[it-CXM0P] = 0;
            }
        } else if addr == GRP0 {
            if this.write_regs[VDELP1] & 1 {
                this.write_regs[GRP1] = this.delay_grp1;
            }

            if this.write_regs[VDELP0] & 1 {
                this.delay_grp0 = value;
                return true;
            }
        } else if addr == GRP1 {
            if this.write_regs[VDELP0] & 1 {
                this.write_regs[GRP0] = this.delay_grp0;
            }

            if this.write_regs[VDELBL] & 1 {
                this.write_regs[ENABL] = this.delay_enabl;
            }

            if this.write_regs[VDELP1] & 1 {
                this.delay_grp1 = value;
                return true;
            }
        } else if addr == ENABL {
            if this.write_regs[VDELBL] & 1 {
                this.delay_enabl = value;
                return true;
            }
        } else if addr == RSYNC {
            // https://atariage.com/forums/topic/279416-emulation-and-rsync/?do=findComment&comment=4041369
            this.current_pixel_clock = 225;
        }

        this.write_regs[addr] = value;
        return true;
    }

    let TOTAL_SCANLINES = 262;
    let HBLANK_PIXELS = 68;
    let PIXELS_PER_SCANLINE = 160;

    func step(this: *TIA) {
        // HBLANK period
        if this.current_pixel_clock < HBLANK_PIXELS {
            this.current_pixel_clock += 1;
            return;
        }

        var current_pixel = this.current_pixel_clock - HBLANK_PIXELS;

        var colubk = calculate_color(this, this.write_regs[COLUBK]);
        var colupf = calculate_color(this, this.write_regs[COLUPF]);
        var colup0 = calculate_color(this, this.write_regs[COLUP0]);
        var colup1 = calculate_color(this, this.write_regs[COLUP1]);
        var color: uint32 = 0x00000000;

        if !(this.write_regs[VBLANK] & 0b10) {
            color = colubk;

            var pfact = false;
            var blact = false;
            var m0act = do_missile(this, current_pixel, 0);
            var m1act = do_missile(this, current_pixel, 1);
            var p0act = do_player(this, current_pixel, 0);
            var p1act = do_player(this, current_pixel, 1);

            // Playfield
            {
                var pfpos = (current_pixel / 4) % 20; // 40 dots across the entire scanline, 20 total bits
                var ctrlpf = this.write_regs[CTRLPF];

                if (ctrlpf & 1) != 0 && (current_pixel / 4) >= 20 {
                    pfpos = 19 - pfpos;
                }

                if (ctrlpf & 0b10) {
                    // score mode
                    colupf = colup0;
                    if (current_pixel / 4) >= 20 {
                        colupf = colup1;
                    }
                }

                if pfpos < 4 {
                    var bits = (this.write_regs[PF0] & 0xF0) >> 4;
                    if bits & (1 << pfpos) {
                        pfact = true;
                    }
                } else if pfpos < 12 {
                    pfpos -= 4;
                    var bits = this.write_regs[PF1];
                    if bits & (1 << (7 - pfpos)) {
                        pfact = true;
                    }
                } else {
                    pfpos -= 12;
                    var bits = this.write_regs[PF2];
                    if bits & (1 << pfpos) {
                        pfact = true;
                    }
                }
            }

            func do_missile(this: *TIA, current_pixel: uint8, index: uint8) -> bool {
                if this.write_regs[RESMP0+index] & 0b10 return false;

                if (this.write_regs[ENAM0+index] & 0b10) != 0 && current_pixel >= this.missile_pos[index] {
                    var size = (this.write_regs[NUSIZ0+index] & 0b00110000) >> 4;
                    size = (1 << size);

                    return current_pixel < this.missile_pos[index] + size;
                }

                return false;
            }

            func do_player(this: *TIA, current_pixel: uint8, index: uint8) -> bool {
                var shape = this.write_regs[NUSIZ0+index] & 0b111;
                var player_pos = this.player_pos[index];

                if current_pixel < player_pos return false;

                var reflect = (this.write_regs[REFP0+index] & 0b1000) != 0;


                if ((shape >= 0 && shape <= 4) || shape == 6) && current_pixel < player_pos + 8 {
                    var bit = 7 - (current_pixel - this.player_pos[index]);
                    if reflect bit = 7 - bit;
                    return (this.write_regs[GRP0+index] & (1 << bit)) != 0;
                }

                if (shape == 1 || shape == 3) && current_pixel >= player_pos + 16 && current_pixel < player_pos + 24 {
                    var bit = 7 - ((current_pixel - 16) - this.player_pos[index]);
                    if reflect bit = 7 - bit;
                    return (this.write_regs[GRP0+index] & (1 << bit)) != 0;
                }

                if (shape == 2 || shape == 3 || shape == 6) && current_pixel >= player_pos + 32 && current_pixel < player_pos + 40 {
                    var bit = 7 - ((current_pixel - 32) - this.player_pos[index]);
                    if reflect bit = 7 - bit;
                    return (this.write_regs[GRP0+index] & (1 << bit)) != 0;
                }

                if (shape == 4 || shape == 6) && current_pixel >= player_pos + 64 && current_pixel < player_pos + 72 {
                    var bit = 7 - ((current_pixel - 64) - this.player_pos[index]);
                    if reflect bit = 7 - bit;
                    return (this.write_regs[GRP0+index] & (1 << bit)) != 0;
                }

                if shape == 5 && current_pixel < player_pos + 16 {
                    var bit = 7 - ((current_pixel - this.player_pos[index]) / 2);
                    if reflect bit = 7 - bit;
                    return (this.write_regs[GRP0+index] & (1 << bit)) != 0;
                }

                if shape == 7 && current_pixel < player_pos + 32 {
                    var bit = 7 - ((current_pixel - this.player_pos[index]) / 4);
                    if reflect bit = 7 - bit;
                    return (this.write_regs[GRP0+index] & (1 << bit)) != 0;
                }

                return false;
            }

            var pfbl_priority = (this.write_regs[CTRLPF] & 0b100) != 0;

            {
                if (this.write_regs[ENABL] & 0b10) != 0 && current_pixel >= this.ball_pos {
                    var bits = (this.write_regs[CTRLPF] & 0b110000) >> 4;
                    var size = (1 << bits);

                    if current_pixel < this.ball_pos+size {
                        blact = true;
                    }
                }

                if (pfact || blact) {
                    color = colupf;
                }

                if m1act color = colup1;
                if p1act color = colup1;

                if m0act color = colup0;
                if p0act color = colup0;

                if pfbl_priority && (pfact || blact) {
                    color = colupf;
                }
            }

            func set_latches(this: *TIA, reg: uint8, b7: bool, b6: bool) {
                var flags: uint8;
                if b7 flags |= 1 << 7;
                if b6 flags |= 1 << 6;
                this.collision_latches[reg-CXM0P] |= flags;
            }

            set_latches(this, CXM0P, m0act && p1act, m0act && p0act);
            set_latches(this, CXM1P, m1act && p1act, m1act && p0act);
            set_latches(this, CXP0FB,p0act && pfact, p0act && blact);
            set_latches(this, CXP1FB,p1act && pfact, p1act && blact);
            set_latches(this, CXM0FB,m0act && pfact, m0act && blact);
            set_latches(this, CXM1FB,m1act && pfact, m1act && blact);
            set_latches(this, CXBLPF,blact && pfact, false);
            set_latches(this, CXPPMM,p0act && p1act, m0act && m1act);
        }

        if current_pixel < this.hmove_in_hblank {
            color = 0x00000000;
        }

        this.framebuffer[current_pixel + this.current_scanline * PIXELS_PER_SCANLINE] = color;

        this.current_pixel_clock += 1;
        if current_pixel+1 >= PIXELS_PER_SCANLINE {
            waiting_for_wsync = false;
            this.current_pixel_clock = 0;

            this.current_scanline += 1;
            this.hmove_in_hblank = 0;

            if this.current_scanline >= TOTAL_SCANLINES {
                this.current_scanline = TOTAL_SCANLINES-1;
            }

            if (this.write_regs[VSYNC] & 0b10) {
                if (this.vsync_ticker > 0 && this.vsync_ticker < 3) this.vsync_ticker += 1;
            } else {
                if this.vsync_ticker >= 3 {
                    this.current_scanline = 0;
                    this.vsync_ticker = 0;
                    vsync_triggered = true;
                }
            }
        }
    }
}

// Input
var reset_held  = false;
var select_held = false;
var joy0_fire_held = false;
var joy0_up_held = false;
var joy0_down_held = false;
var joy0_left_held = false;
var joy0_right_held = false;

var step_cpu = false;
func key_callback(window: *GLFWwindow, key: int32, scancode: int32, action: int32, mods: int32) -> void {
    if key == GLFW_KEY_TAB && (action == 1 || action == 2) {
        step_cpu = true;
    }

    if key == GLFW_KEY_GRAVE_ACCENT && (action == 1 || action == 2) {
        show_debugging_stuff = !show_debugging_stuff;
    }

    if key == GLFW_KEY_F1 && (action == 1 || action == 2) {
        do_reset = true;
    }

    var held = (action == 1 || action == 2);

    if key == GLFW_KEY_SPACE {
        joy0_fire_held = held;
    }

    if key == GLFW_KEY_UP {
        joy0_up_held = held;
    }

    if key == GLFW_KEY_DOWN {
        joy0_down_held = held;
    }

    if key == GLFW_KEY_LEFT {
        joy0_left_held = held;
    }

    if key == GLFW_KEY_RIGHT {
        joy0_right_held = held;
    }

    if key == GLFW_KEY_1 {
        reset_held = held;
    }

    if key == GLFW_KEY_2 {
        select_held = held;
    }

    if key == GLFW_KEY_4 {
        if action == 1 {
            num_steps = 1;
        }
    }

    if key == GLFW_KEY_5 {
        if action == 1 {
            num_steps = 20;
        }
    }
}

func debug_func (source: GLenum, type: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: *GLchar, userParam: *void) -> void {
    printf("Message: %s\n", message);
    assert(false);
}

var waiting_for_wsync = false;
var vsync_triggered = false;
var single_step = false;
var num_steps = 1;
var show_debugging_stuff = false;
var do_reset = true;

func main(argc: int32, argv: **uint8) {

    if (argc < 2) {
        printf("Please provide a path to a ROM file to run!\n");
        return;
    }

    for 2..<argc {
        if to_string(argv[it]) == "debug" {
            show_debugging_stuff = true;
        }
    }

    var result = read_entire_file(to_string(argv[1]));
    if !result.success {
        printf("Could not open file: %s\n", argv[1]);
        return;
    }

    var rom_image = result.result;
    if rom_image.length == 0 || (rom_image.length % 2048) != 0 {
        printf("Invalid or corrupt ROM image. Size %d\n", rom_image.length);
        return;
    }

    if true {
        var exe_path = get_executable_path();
        printf("Exe path: '%.*s'\n", exe_path.length, exe_path.data);
        set_working_directory(strip_path_filename(exe_path));
    }

    if glfwInit() != 1 return;

    glfwWindowHint(GLFW_SCALE_TO_MONITOR, 1);

    var window = glfwCreateWindow(1280, 720, "U0VDUkVUIFBST0pFQ1QgRE8gTk9UIExFQUs=", null, null);
    if !window {
        glfwTerminate();
        return;
    }

    glfwMakeContextCurrent(window);

    glfwSwapInterval(1); // @Hack

    glfwSetKeyCallback(window, cast() key_callback);

    func get_proc(name: string) -> *void {
        var addr = glfwGetProcAddress(name.data);
        return addr;
    }

    init_gl_functions(get_proc);

    // glEnable(GL_FRAMEBUFFER_SRGB);

    // glDebugMessageCallback(cast() debug_func, null);
    // glEnable(GL_DEBUG_OUTPUT);

    var cpu = M6507.make();

    var cart: Memory_Map_Entry;
    cart.cbdata = *rom_image;
    cart.start = 0x1000;
    cart.end   = 0x1FFF;
    cart.read  = cartridge_read;
    cart.write = cartridge_write;

    cpu.memory.mappings.add(cart);

    var pia: PIA;
    var pia_map: Memory_Map_Entry;
    pia_map.cbdata = *pia;
    pia_map.start = 0x0080;
    pia_map.end   = 0x0FFF;
    pia_map.read  = PIA.read;
    pia_map.write = PIA.write;

    cpu.memory.mappings.add(pia_map);

    for *pia.ram {
        <<it = 0x00;
    }

    var tia: TIA;
    tia.init();
    var tia_map: Memory_Map_Entry;
    tia_map.cbdata = *tia;
    tia_map.start = 0x0000;
    tia_map.end   = 0x0F7F;
    tia_map.read  = TIA.read;
    tia_map.write = TIA.write;

    cpu.memory.mappings.add(tia_map);

    var scanlines = TIA.TOTAL_SCANLINES; // NTSC, PAL is 312
    var pixels_per_scanline = TIA.PIXELS_PER_SCANLINE;
    var framebuffer = cast(*uint32) malloc(cast() (scanlines * pixels_per_scanline * sizeof(uint32)));
    tia.framebuffer.data  = framebuffer;
    tia.framebuffer.count = scanlines * pixels_per_scanline;

    var fb_tex: GLuint;
    glGenTextures(1, *fb_tex);
    glBindTexture(GL_TEXTURE_2D, fb_tex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cast() pixels_per_scanline, cast() scanlines, 0, GL_RGBA, GL_UNSIGNED_BYTE, framebuffer);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

    printf("sizeof(ma_device): %d\n", strideof(Mini_Audio.ma_device));

    var ui_context: UI.Context;
    var ui_renderer = UI_GL_Renderer.make(*ui_context);
    ui_context.renderer = *ui_renderer;
    var font = ui_renderer.make_font("data/Skytree_Mono.ttf", 32.0);


    var label  = UI.Label.new(font, "Hello, Sailor!");
    var label2 = UI.Label.new(font, "Test");

    var layout = UI.Layout_Linear.new(*ui_context);
    // layout.add_view(label);
    // layout.add_view(label2);
    ui_context.set_content_view(layout);

    Mini_Audio.init_audio(*tia);

    step_cpu = true;
    var step_count = 0;

    var tia_steps: int64 = 0;
    var clocks_ticked : int64 = 0;
    var pia_cycles_pending: int64 = 0;
    var cpu_cycles_pending: int64 = 0;

    while !glfwWindowShouldClose(window) {
        glClear(GL_COLOR_BUFFER_BIT);
        glClearColor(0.2, 0.2, 0.2, 1);

        if do_reset {
            var entry_point = cpu.get_word(0xFFFC);
            tia.current_pixel_clock = 0;
            tia.current_scanline = 0;

            cpu.PC = entry_point;
            clocks_ticked = 0;
            do_reset = false;
        }

        // step_cpu = true;
        if step_cpu {
            if single_step step_cpu = false;
            while !vsync_triggered {
                tia.step();
                tia_steps += 1;

                if tia_steps > 0 && tia_steps % 3 == 0 {
                    pia_cycles_pending += 1;
                    cpu_cycles_pending += 1;
                    clocks_ticked      += 1;
                    tia_steps = 0;
                }

                for 0..<pia_cycles_pending {
                    pia.step();
                }
                pia_cycles_pending = 0;

                if !waiting_for_wsync {
                    var clks_needed = cpu.do_dry_run();

                    if clks_needed < cpu_cycles_pending {
                        var clks = cpu.step();
                        cpu_cycles_pending -= clks;

                        if cpu.PC == 0xF00C {
                            // single_step = true;
                        }

                        if clks == 0 {
                            step_cpu = false;
                            break;
                        }
                    }
                } else {
                    cpu_cycles_pending = 0;
                }

                step_count += 1;

                if single_step && step_count > num_steps {
                    step_count -= num_steps;
                    break;
                } else if step_count > num_steps step_count -= num_steps;
            }

            vsync_triggered = false;
        }

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        var width: int32;
        var height: int32;
        glfwGetWindowSize(window, *width, *height);
        var aspect: float = cast(float) width / height;

        var xscale: float = 1;
        var yscale: float = 1;

        // @TODO I am not sure what is the best thing to do on Windows/Linux
        // Using this on Windows seems to mess up rendering in that nothing gets drawn..
        #if true {
            glfwGetWindowContentScale(window, *xscale, *yscale);
        }

        #if os(MacOSX) {
            glViewport(0, 0, cast(GLsizei) (width * xscale), cast(GLsizei) (height * yscale));
        } else {
            glViewport(0, 0, cast(GLsizei) (width), cast(GLsizei) (height));
        }

        if show_debugging_stuff {
            glOrtho(0, width, height, 0, -1, 1);
        } else {
            glOrtho(0, 160, 192+20/*visible scanlines*/, 0, -1, 1);
        }

        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, fb_tex);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, cast() pixels_per_scanline, cast() scanlines, 0, GL_RGBA, GL_UNSIGNED_BYTE, framebuffer); // @Speed

        var scale: float = 1;

        if show_debugging_stuff {
            scale = xscale;
        }

        var playfield_width: float = pixels_per_scanline * scale;
        var playfield_height: float = scanlines * scale;

        if !show_debugging_stuff {
            playfield_height = TIA.TOTAL_SCANLINES;
            playfield_width = 160;
        }

        {
            var x: float = 0;
            var y: float = 0;

            if !show_debugging_stuff {
                y = -33;
            }

            var width = playfield_width;
            var height = playfield_height;

            glBegin(GL_TRIANGLES);
                glTexCoord2f(0, 0);
                glVertex3f(x, y, 0);
                glTexCoord2f(1, 0);
                glVertex3f(x+width, y, 0);
                glTexCoord2f(1, 1);
                glVertex3f(x+width, y+height, 0);

                glTexCoord2f(1, 1);
                glVertex3f(x+width, y+height, 0);
                glTexCoord2f(0, 1);
                glVertex3f(x, y+height, 0);
                glTexCoord2f(0, 0);
                glVertex3f(x, y, 0);
            glEnd();
        }

        if true {
            glEnable(GL_BLEND);
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

            glLoadIdentity();
            glOrtho(0, width, height, 0, -1, 1);

            ui_context.content_view.draw();

            glDisable(GL_BLEND);
        }

        if show_debugging_stuff {
            glEnable(GL_BLEND);
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

            var text_height: float = 32;
            var y_offset: float;
            var x_offset: float;

            ui_renderer.draw_string(playfield_width, y_offset + text_height*1, "  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F", font);
            y_offset += text_height;

            for pia.ram {
                if (it_index % 16) == 0 && it_index != 0 {
                    x_offset = 0;
                    y_offset += 32;
                }

                if (it_index % 16) == 0 {
                    var buf: [32] uint8;
                    snprintf(buf.data, buf.count, "%X ", (it_index / 16) + 8);
                    x_offset += ui_renderer.draw_string(playfield_width + x_offset, y_offset + text_height, to_string(buf.data), font);
                }

                var buf: [4] uint8;
                snprintf(buf.data, cast() buf.count, "%02X ", it);
                var width = ui_renderer.draw_string(playfield_width + x_offset, y_offset + text_height, to_string(buf.data), font);
                x_offset += width;
            }

            y_offset += text_height;

            var buf: [32] uint8;
            snprintf(buf.data, buf.count, "X: %02X", cpu.regs[M6502.REG_X]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*1, to_string(buf.data), font);


            snprintf(buf.data, buf.count, "Y: %02X", cpu.regs[M6502.REG_Y]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*2, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "A: %02X", cpu.regs[M6502.REG_A]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*3, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "S: %02X", cpu.regs[M6502.REG_S]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*4, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "P: %02X", cpu.P);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*5, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "PC: %04X", cpu.PC);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*6, to_string(buf.data), font);

            y_offset += text_height*6;

            snprintf(buf.data, buf.count, "PF0: %02X", tia.write_regs[TIA.PF0]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*1, to_string(buf.data), font);
            snprintf(buf.data, buf.count, "PF1: %02X", tia.write_regs[TIA.PF1]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*2, to_string(buf.data), font);
            snprintf(buf.data, buf.count, "PF2: %02X", tia.write_regs[TIA.PF2]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*3, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "COLUPF: %02X", tia.write_regs[TIA.COLUPF]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*4, to_string(buf.data), font);
            snprintf(buf.data, buf.count, "COLUBK: %02X", tia.write_regs[TIA.COLUBK]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*5, to_string(buf.data), font);

            // snprintf(buf.data, buf.count, "CTRLPF: %02X", tia.write_regs[TIA.CTRLPF]);
            // ui_renderer.draw_string(playfield_width, y_offset + text_height*6, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "BALL POS: %d", tia.ball_pos);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*6, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "P0 POS: %d", tia.player_pos[0]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*7, to_string(buf.data), font);
            snprintf(buf.data, buf.count, "P1 POS: %d", tia.player_pos[1]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*8, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "GRP0: %d", tia.write_regs[TIA.GRP0]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*9, to_string(buf.data), font);
            snprintf(buf.data, buf.count, "GRP1: %d", tia.write_regs[TIA.GRP1]);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*10, to_string(buf.data), font);

            snprintf(buf.data, buf.count, "clocks ticked: %lld", clocks_ticked);
            ui_renderer.draw_string(playfield_width, y_offset + text_height*11, to_string(buf.data), font);

            // snprintf(buf.data, buf.count, "COMBAT SCANLINE: %02X", cpu.get_byte(0xB4));
            // ui_renderer.draw_string(playfield_width, y_offset + text_height*7, to_string(buf.data), font);

            glDisable(GL_BLEND);
        }

        glfwPollEvents();
        glfwSwapBuffers(window);
    }

    glfwTerminate();

    // Mini_Audio.stop_audio();
}