
#import "Basic"; // assert

typealias Memory_Map_Read_Handler  = (entry: *Memory_Map_Entry, addr: uint16) -> uint8;
typealias Memory_Map_Write_Handler = (entry: *Memory_Map_Entry, addr: uint16, value: uint8) -> void;

struct Memory_Map_Entry {
    var cbdata: *void;
    var start: uint16;
    var end  : uint16; // points to the last byte handled by the handlers

    var read : Memory_Map_Read_Handler;
    var write: Memory_Map_Write_Handler;
}

struct Memory_Map {
    var mappings: [..] Memory_Map_Entry;

    func read(this: *Memory_Map, addr: uint16) -> (success: bool, value: uint8) {
        for * this.mappings {
            if addr >= it.start && addr <= it.end {
                if it.read return (true, it.read(addr));
            }
        }

        printf("FAIL to read from unmapped address: %04X\n", addr);
        return (false, cast(uint8) -1);
    }

    func write(this: *Memory_Map, addr: uint16, value: uint8) -> bool {
        for * this.mappings {
            if addr >= it.start && addr <= it.end {
                if it.write {
                    it.write(addr, value);
                    return true;
                }
            }
        }

        printf("FAIL to write to unmapped address: %04X, value %02X\n", addr, value);
        return false;
    }
}

struct M6507 {

    let ADDRESS_BITS = 0b0001111111111111; // We only have 13 address lines on this chip
    let STACK_ADDRESS: uint16 = 0x100; // Stack starts in page 1 of memory

    // Bit format of opcode is generally aaabbbcc,
    // aaa = operation
    // bbb = addressing mode
    // cc  = register
    // Though this isnt consistently the case, there are many gaps
    // in the instruction set and many instructions are just outliers.
    // We only take advantage of this bit pattern in cases where we know
    // they are correct; this helps reduce code bloat from repeating
    // similar operations across multiple opcodes in the switch in step().

    let BBB_BITS   = (0b111 << 2);
    let MODE_ZP    = (0b001 << 2);
    let MODE_ZP_Y  = (0b100 << 2);
    let MODE_ZP_X  = (0b101 << 2); // In cc=10 instructions, becomes zeropage,Y
    let MODE_ABS   = (0b011 << 2);
    let MODE_ABS_X = (0b111 << 2); // In cc=10 instructions, becomes absolute,Y

    let CC_BITS = 0b00000011;

    // Order is chosen to coincide the fact that  he lowest two bits
    // of the instruction format somewhat indicate the destination regiters.
    // Note that cc = 11 refers to undocumented instructions. Those instructions
    // are not implemented in this program.
    let REG_Y = 0; // cc = 00
    let REG_A = 1; // cc = 01
    let REG_X = 2; // cc = 10

    let REG_S = 3;

    var regs: [4] uint8;
    var PC: uint16;
    
    var P : uint8; // Status register

    var memory: Memory_Map;

    let STATUS_CARRY   : uint8 = (1 << 0); // 0 = no carry, 1 = carry
    let STATUS_ZERO    : uint8 = (1 << 1); // 0 = non zero, 1 = zero
    let STATUS_IRQ     : uint8 = (1 << 2); // 0 = IRQ enable, 1 = IRQ disable
    let STATUS_DEC     : uint8 = (1 << 3); // 0 = normal, 1 = BCD mode
    let STATUS_BREAK   : uint8 = (1 << 4); // 0 = IRQ/NMI, 1 = RESET or BRK/PHP
    let STATUS_OVERFLOW: uint8 = (1 << 6); // 1 = overflow
    let STATUS_SIGN    : uint8 = (1 << 7); // 0 = positive, 1 = negative

    func set_flags(this: *M6507, mask: uint8, values: uint8) {
        this.P = (this.P & ~mask) | (values & mask);
    }

    let NO_OFFSET: uint8   = 0;
    let X_OFFSET : uint8   = 1;
    let Y_OFFSET : uint8   = 2;

    func zero_page(this: *M6507, offset: uint8, register: uint8 = NO_OFFSET) -> uint16 {
        return absolute(this, offset, register);
    }

    func absolute(this: *M6507, offset: uint16, register: uint8 = NO_OFFSET) -> uint16 {
        var reg: uint8;
        if      register == X_OFFSET reg = this.regs[REG_X];
        else if register == Y_OFFSET reg = this.regs[REG_Y];
        return offset + reg;
    }

    func indirect(this: *M6507, offset: uint8, register: uint8) -> uint16 {
        if register == X_OFFSET {
            var lo: uint16 = zero_page(this, offset,   X_OFFSET);
            var hi: uint16 = zero_page(this, offset+1, X_OFFSET);

            return absolute(this, lo | (hi << 8));
        } else if register == Y_OFFSET {
            var lo: uint16 = zero_page(this, offset);
            var hi: uint16 = zero_page(this, offset+1);

            var addr = lo | (hi << 8);

            return absolute(this, addr, Y_OFFSET);
        }

        assert(false);
    }

    func do_reg2reg_mov(this: *M6507, dst: uint8, src: uint8, flag_mask: uint8) -> int {
        this.regs[dst] = this.regs[src];

        var flags = this.regs[dst] & STATUS_SIGN;
        if this.regs[dst] == 0 flags |= STATUS_ZERO;

        this.set_flags(flag_mask, flags);
        return 2;
    }

    func do_load_imm(this: *M6507, dst: uint8) -> int {
        var value = this.get_byte(this.PC);
        this.PC += 1;

        this.regs[dst] = value;

        var flags = this.regs[dst] & STATUS_SIGN;
        if this.regs[dst] == 0 flags |= STATUS_ZERO;

        this.set_flags(STATUS_SIGN | STATUS_ZERO, flags);
        return 2;
    }

    func do_cond_branch(this: *M6507, cond: bool) -> int {
        var dd = cast(int8) get_byte(this, this.PC);
        this.PC += 1;

        var clks_ticked = 2;

        if (cond) {
            var old_pc = this.PC;
            this.PC += cast(uint16) cast(int16) dd;

            // If we take the branch, add a clock tick
            clks_ticked += 1;

            // If the branch crosses a page boundary
            // add a clock tick
            if (old_pc & 0xFF00) != (this.PC & 0xFF00) {
                clks_ticked += 1;
            }
        }

        return clks_ticked;
    }

    func step(this: *M6507) -> int {
        // printf("PC: %04X\n", this.PC);

        var op = this.get_byte(this.PC);
        this.PC += 1;

        // printf("REG A: %02X\n", this.regs[REG_A]);
        // printf("REG X: %02X\n", this.regs[REG_X]);
        // printf("REG Y: %02X\n", this.regs[REG_Y]);
        // printf("REG S: %02X\n", this.regs[REG_S]);
        // printf("REG P: %02X\n", this.P);

        // printf("Opcode: %02X\n", op);

        var clks_ticked = 0;

        switch op {
            case 0xA8:
                clks_ticked += do_reg2reg_mov(this, REG_Y, REG_X, STATUS_SIGN | STATUS_ZERO);
            case 0xAA:
                clks_ticked += do_reg2reg_mov(this, REG_X, REG_A, STATUS_SIGN | STATUS_ZERO);
            case 0xBA:
                clks_ticked += do_reg2reg_mov(this, REG_X, REG_S, STATUS_SIGN | STATUS_ZERO);
            case 0x98:
                clks_ticked += do_reg2reg_mov(this, REG_A, REG_Y, STATUS_SIGN | STATUS_ZERO);
            case 0x8A:
                clks_ticked += do_reg2reg_mov(this, REG_A, REG_X, STATUS_SIGN | STATUS_ZERO);
            case 0x9A:
                clks_ticked += do_reg2reg_mov(this, REG_S, REG_X, 0);

            case 0xA9, 0xA2, 0xA0:
                var reg = op & CC_BITS;
                clks_ticked += do_load_imm(this, reg);

            case 0xA4, 0xA5, 0xA6, 0xB4, 0xB5, 0xB6:
                var reg = op & CC_BITS;
                var nn = get_byte(this, this.PC);
                this.PC += 1;

                clks_ticked += 3;

                var offset_reg = NO_OFFSET;

                var mode = op & BBB_BITS;
                if mode == MODE_ZP_X {
                    offset_reg = X_OFFSET;
                    if reg == REG_X offset_reg = Y_OFFSET;

                    clks_ticked += 1;
                }

                this.regs[reg] = this.get_byte(zero_page(this, nn, offset_reg));

                var flags = this.regs[reg] & STATUS_SIGN;
                if this.regs[reg] == 0 flags |= STATUS_ZERO;

                this.set_flags(STATUS_SIGN | STATUS_ZERO, flags);
            case 0xAC, 0xAD, 0xAE, 0xBC, 0xBD, 0xBE:
                var reg = op & CC_BITS;
                var nnnn = this.get_word(this.PC);
                this.PC += 2;

                clks_ticked += 4;

                var offset_reg = NO_OFFSET;

                var mode = op & BBB_BITS;
                if mode == MODE_ABS_X {
                    offset_reg = X_OFFSET;
                    if reg == REG_X offset_reg = Y_OFFSET;

                    // @Incomplete add a cycle if cross page boundary
                }

                this.regs[reg] = this.get_byte(absolute(this, nnnn, offset_reg));

                var flags = this.regs[reg] & STATUS_SIGN;
                if this.regs[reg] == 0 flags |= STATUS_ZERO;

                this.set_flags(STATUS_SIGN | STATUS_ZERO, flags);

            case 0x84, 0x85, 0x86, 0x94, 0x95, 0x96:
                var reg = op & CC_BITS;
                var nn = get_byte(this, this.PC);
                this.PC += 1;

                clks_ticked += 3;

                var offset_reg = NO_OFFSET;

                var mode = op & BBB_BITS;
                if mode == MODE_ZP_X {
                    offset_reg = X_OFFSET;
                    if reg == REG_X offset_reg = Y_OFFSET;

                    clks_ticked += 1;
                }

                this.set_byte(zero_page(this, nn, offset_reg), this.regs[reg]);

            case 0x8C, 0x8D, 0x8E, 0x9D, 0x99:
                var reg = op & CC_BITS;
                var nnnn = this.get_word(this.PC);
                this.PC += 2;

                clks_ticked += 4;

                var offset_reg = NO_OFFSET;

                var mode = op & BBB_BITS;
                if mode == MODE_ABS_X {
                    offset_reg = X_OFFSET;
                    if reg == REG_X offset_reg = Y_OFFSET;

                    clks_ticked += 1;
                }

                this.set_byte(absolute(this, nnnn, offset_reg), this.regs[reg]);

            case 0x81, 0x91:
                var reg = op & CC_BITS;
                var nn = get_byte(this, this.PC);
                this.PC += 1;

                clks_ticked += 6;

                var offset_reg = NO_OFFSET;

                var mode = op & BBB_BITS;
                if mode == MODE_ZP_X {
                    offset_reg = X_OFFSET;
                } else if mode == MODE_ZP_Y {
                    offset_reg = Y_OFFSET;
                }

                this.set_byte(indirect(this, nn, offset_reg), this.regs[reg]);

            case 0x18:
                this.set_flags(STATUS_CARRY, 0);
                clks_ticked += 2;
            case 0x58:
                this.set_flags(STATUS_IRQ, 0);
                clks_ticked += 2;
            case 0xD8:
                this.set_flags(STATUS_DEC, 0);
                clks_ticked += 2;
            case 0xB8:
                this.set_flags(STATUS_OVERFLOW, 0);
                clks_ticked += 2;
            case 0x38:
                this.set_flags(STATUS_CARRY, STATUS_CARRY);
                clks_ticked += 2;
            case 0x78:
                this.set_flags(STATUS_IRQ, STATUS_IRQ);
                clks_ticked += 2;
            case 0xF8:
                this.set_flags(STATUS_DEC, STATUS_DEC);
                clks_ticked += 2;
            case 0xEA: // NOP
                clks_ticked += 2;

            case 0x4C:
                var nnnn = this.get_word(this.PC);
                this.PC = nnnn;
                clks_ticked += 3;
            case 0x6C:
                var nnnn = this.get_word(this.PC);
                this.PC = this.get_word(absolute(this, nnnn));
                clks_ticked += 5;
            case 0x20:
                var nnnn = this.get_word(this.PC);
                this.set_word(STACK_ADDRESS + this.regs[REG_S], this.PC+2);
                // Do we need to inc/dec the stack pointer here?

                this.PC = nnnn;
                clks_ticked += 6;
            case 0xE8, 0xC8: // INC X, INC Y
                var reg = REG_X;
                if op == 0xC8 reg = REG_Y;

                this.regs[reg] += 1;

                var flags = this.regs[reg] & STATUS_SIGN;
                if this.regs[reg] == 0 flags |= STATUS_ZERO;

                this.set_flags(STATUS_SIGN | STATUS_ZERO, flags);

                clks_ticked += 2;

            case 0x10:
                clks_ticked += do_cond_branch(this, (this.P & STATUS_SIGN) == 0);
            case 0x30:
                clks_ticked += do_cond_branch(this, (this.P & STATUS_SIGN) != 0);
            case 0x50:
                clks_ticked += do_cond_branch(this, (this.P & STATUS_OVERFLOW) == 0);
            case 0x70:
                clks_ticked += do_cond_branch(this, (this.P & STATUS_OVERFLOW) != 0);
            case 0x90:
                clks_ticked += do_cond_branch(this, (this.P & STATUS_CARRY) == 0);
            case 0xB0:
                clks_ticked += do_cond_branch(this, (this.P & STATUS_CARRY) != 0);
            case 0xD0:
                clks_ticked += do_cond_branch(this, (this.P & STATUS_ZERO) == 0);
            case 0xF0:
                clks_ticked += do_cond_branch(this, (this.P & STATUS_ZERO) != 0);
        
        }

        if clks_ticked == 0 {
            printf("Unhandled opcode %02X\n", op);
        }

        return clks_ticked;
    }

    func get_byte(this: *M6507, _addr: uint16) -> uint8 {
        var addr = _addr;
        addr &= ADDRESS_BITS;

        var success: bool;
        var value: uint8;

        (success, value) = this.memory.read(addr);
        assert(success, "get_byte failed");
        return value;
    }

    func set_byte(this: *M6507, _addr: uint16, value: uint8) {
        var addr = _addr;
        addr &= ADDRESS_BITS;

        var success: bool;

        success = this.memory.write(addr, value);
        assert(success, "set_byte failed");
    }

    func set_word(this: *M6507, _addr: uint16, value: uint16) {
        var lo: uint8 = cast(uint8) (value & 0xFF);
        var hi: uint8 = cast(uint8) ((value >> 8) & 0xFF);
        set_byte(this, _addr, lo);
        set_byte(this, _addr+1, hi);
    }

    func get_word(this: *M6507, addr: uint16) -> uint16 {
        var lo: uint16 = get_byte(this, addr);
        var hi: uint16 = get_byte(this, addr+1);

        return lo | (hi << 8);
    }

    
}