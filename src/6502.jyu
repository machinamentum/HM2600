
#import "Basic"; // assert

struct M6507 {

    // Bit format of opcode is generally aaabbbcc,
    // aaa = operation
    // bbb = addressing mode
    // cc  = register
    // Though this isnt consistently the case, there are many gaps
    // in the instruction set and many instructions are just outliers.
    // We only take advantage of this bit pattern in cases where we know
    // they are correct; this helps reduce code bloat from repeating
    // similar operations across multiple opcodes in the switch in step().

    let CC_BITS = 0x03;

    // Order is chosen to coincide the fact that  he lowest two bits
    // of the instruction format somewhat indicate the destination regiters.
    // Note that cc = 11 refers to undocumented instructions. Those instructions
    // are not implemented in this program.
    let REG_Y = 0; // cc = 00
    let REG_A = 1; // cc = 01
    let REG_X = 2; // cc = 10

    let REG_S = 3;

    var regs: [4] uint8;
    var PC: uint16;
    
    var P : uint8; // Status register

    let STATUS_CARRY   : uint8 = (1 << 0); // 0 = no carry, 1 = carry
    let STATUS_ZERO    : uint8 = (1 << 1); // 0 = non zero, 1 = zero
    let STATUS_IRQ     : uint8 = (1 << 2); // 0 = IRQ enable, 1 = IRQ disable
    let STATUS_DEC     : uint8 = (1 << 3); // 0 = normal, 1 = BCD mode
    let STATUS_BREAK   : uint8 = (1 << 4); // 0 = IRQ/NMI, 1 = RESET or BRK/PHP
    let STATUS_OVERFLOW: uint8 = (1 << 6); // 1 = overflow
    let STATUS_SIGN    : uint8 = (1 << 7); // 0 = positive, 1 = negative

    func set_flags(this: *M6507, mask: uint8, values: uint8) {
        this.P = (this.P & ~mask) | (values & mask);
    }

    var ram: [128] uint8;

    let NO_OFFSET = 0;
    let X_OFFSET    = 1;
    let Y_OFFSET    = 2;

    func zero_page(this: *M6507, offset: uint8, register: uint8) -> *uint8 {
        return absolute(this, offset, register);
    }

    func absolute(this: *M6507, offset: uint16, register: uint8) -> *uint8 {
        var reg: uint8;
        if      register == X_OFFSET reg = this.regs[REG_X];
        else if register == Y_OFFSET reg = this.regs[REG_Y];
        return get_byte_ptr(this, offset + reg);
    }

    func indirect(this: *M6507, offset: uint8, register: uint8) -> *uint8 {
        if register == X_OFFSET {
            var lo: uint16 = <<zero_page(this, offset,   X_OFFSET);
            var hi: uint16 = <<zero_page(this, offset+1, X_OFFSET);

            return absolute(this, lo | (hi << 8), NO_OFFSET);
        } else if register == Y_OFFSET {
            var lo: uint16 = <<zero_page(this, offset,   NO_OFFSET);
            var hi: uint16 = <<zero_page(this, offset+1, NO_OFFSET);

            var addr = lo | (hi << 8);

            return absolute(this, addr, Y_OFFSET);
        }

        assert(false);
    }

    func do_reg2reg_mov(this: *M6507, dst: uint8, src: uint8, flag_mask: uint8) -> int {
        this.regs[dst] = this.regs[src];

        var flags = this.regs[dst] & STATUS_SIGN;
        if this.regs[dst] == 0 flags |= STATUS_ZERO;

        this.set_flags(flag_mask, flags);
        return 2;
    }

    func do_load_imm(this: *M6507, dst: uint8) -> int {
        var value = this.get_byte(this.PC);
        this.PC += 1;

        this.regs[dst] = value;

        var flags = this.regs[dst] & STATUS_SIGN;
        if this.regs[dst] == 0 flags |= STATUS_ZERO;

        this.set_flags(STATUS_SIGN | STATUS_ZERO, flags);
        return 2;
    }

    func step(this: *M6507) {
        var op = this.get_byte(this.PC);
        this.PC += 1;

        var clks_ticked = 0;

        switch op {
            case 0xA8:
                clks_ticked += do_reg2reg_mov(this, REG_Y, REG_X, STATUS_SIGN | STATUS_ZERO);
            case 0xAA:
                clks_ticked += do_reg2reg_mov(this, REG_X, REG_A, STATUS_SIGN | STATUS_ZERO);
            case 0xBA:
                clks_ticked += do_reg2reg_mov(this, REG_X, REG_S, STATUS_SIGN | STATUS_ZERO);
            case 0x98:
                clks_ticked += do_reg2reg_mov(this, REG_A, REG_Y, STATUS_SIGN | STATUS_ZERO);
            case 0x8A:
                clks_ticked += do_reg2reg_mov(this, REG_A, REG_X, STATUS_SIGN | STATUS_ZERO);
            case 0x9A:
                clks_ticked += do_reg2reg_mov(this, REG_S, REG_X, 0);

            case 0xA9, 0xA2, 0xA0:
                var reg = op & CC_BITS;
                clks_ticked += do_load_imm(this, reg);
        }
    }

    func get_byte(this: *M6507, addr: uint16) -> uint8 {
        return <<get_byte_ptr(this, addr);
    }

    func get_byte_ptr(this: *M6507, addr: uint16) -> *uint8 {
        
    }
}